// Generated by CoffeeScript 1.8.0
(function() {
  var CALCULATION_FAILED, HEURISTIC_BEST_AREA_FIT, HEURISTIC_BEST_LONG_SIDE_FIT, HEURISTIC_BEST_SHORT_SIDE_FIT, HEURISTIC_BOTTOM_LEFT_RULE, HEURISTIC_CONTACT_POINT_RULE, HEURISTIC_RING_MULTI_BIN, HEURISTIC_RING_SINGLE_BIN, MAX_BIN_HEIGHT, MAX_BIN_WIDTH, MAX_MARGIN, MAX_PADDING, MaxRects, Rectangle, assert, calcOcupiedArea, calcSurfaceArea, commonIntervalLength, debuglog, exports, _;

  _ = require("underscore");

  Rectangle = require("./rectangle").Rectangle;

  debuglog = require("debug")("maxrects");

  assert = require("assert");

  CALCULATION_FAILED = "failed";

  HEURISTIC_BEST_SHORT_SIDE_FIT = "BSSF";

  HEURISTIC_BEST_LONG_SIDE_FIT = "BLSF";

  HEURISTIC_BEST_AREA_FIT = "BAF";

  HEURISTIC_BOTTOM_LEFT_RULE = "BL";

  HEURISTIC_CONTACT_POINT_RULE = "CP";

  HEURISTIC_RING_SINGLE_BIN = {};

  HEURISTIC_RING_SINGLE_BIN[HEURISTIC_BEST_SHORT_SIDE_FIT] = HEURISTIC_BEST_LONG_SIDE_FIT;

  HEURISTIC_RING_SINGLE_BIN[HEURISTIC_BEST_LONG_SIDE_FIT] = HEURISTIC_BEST_AREA_FIT;

  HEURISTIC_RING_SINGLE_BIN[HEURISTIC_BEST_AREA_FIT] = HEURISTIC_BOTTOM_LEFT_RULE;

  HEURISTIC_RING_SINGLE_BIN[HEURISTIC_BOTTOM_LEFT_RULE] = HEURISTIC_CONTACT_POINT_RULE;

  HEURISTIC_RING_MULTI_BIN = {};

  HEURISTIC_RING_MULTI_BIN[HEURISTIC_BEST_SHORT_SIDE_FIT] = HEURISTIC_BEST_LONG_SIDE_FIT;

  HEURISTIC_RING_MULTI_BIN[HEURISTIC_BEST_LONG_SIDE_FIT] = HEURISTIC_BEST_AREA_FIT;

  HEURISTIC_RING_MULTI_BIN[HEURISTIC_BEST_AREA_FIT] = HEURISTIC_BOTTOM_LEFT_RULE;

  MAX_BIN_WIDTH = 2048;

  MAX_BIN_HEIGHT = 2048;

  MAX_PADDING = 64;

  MAX_MARGIN = 64;

  calcSurfaceArea = function(rects) {
    var rect, result, _i, _len;
    result = 0;
    for (_i = 0, _len = rects.length; _i < _len; _i++) {
      rect = rects[_i];
      result += rect.width * rect.height;
    }
    return result;
  };

  calcOcupiedArea = function(rects, binWidth, binHeight) {
    var bottom, height, left, rect, right, top, width, _i, _len;
    left = binWidth;
    right = 0;
    top = binHeight;
    bottom = 0;
    debuglog("[calcOcupiedArea] left:" + left + ", right:" + right + ", top:" + top + ", bottom:" + bottom);
    for (_i = 0, _len = rects.length; _i < _len; _i++) {
      rect = rects[_i];
      if (left > rect.left) {
        left = rect.left;
      }
      if (right < rect.right) {
        right = rect.right;
      }
      if (top > rect.top) {
        top = rect.top;
      }
      if (bottom < rect.bottom) {
        bottom = rect.bottom;
      }
    }
    width = Math.abs(right - left);
    height = Math.abs(bottom - top);
    debuglog("[calcOcupiedArea] width:" + width + "i, height:" + height + ", area:" + (width * height));
    return width * height;
  };

  commonIntervalLength = function(i1start, i1end, i2start, i2end) {
    if (i1end < i2start || i2end < i1start) {
      return 0;
    }
    return Math.min(i1end, i2end) - Math.max(i1start, i2start);
  };

  MaxRects = (function() {
    function MaxRects(margin, padding, enableMultiArrangment, verbos) {
      if (margin == null) {
        margin = 2;
      }
      if (padding == null) {
        padding = 0;
      }
      this.enableMultiArrangment = enableMultiArrangment != null ? enableMultiArrangment : false;
      this.verbos = verbos != null ? verbos : false;
      debuglog("[constructor] @enableMultiArrangment:" + this.enableMultiArrangment);
      padding = parseInt(padding, 10) || 0;
      this.padding = padding < 0 ? 0 : padding > MAX_PADDING ? MAX_PADDING : padding;
      margin = parseInt(margin, 10) || 0;
      this.margin = margin < 0 ? 0 : margin > MAX_MARGIN ? MAX_MARGIN : margin;
      this.binWidth = 2;
      this.binHeight = 2;
      this.score1 = 0;
      this.score2 = 0;
      this.surfaceArea = 0;
      this.usedRectangles = [];
      this.freeRectangles = [];
      this.sourceList = null;
      this._sourceList = null;
      this.callback = null;
      this.currentArrangementByHeuristicKV = {};
      this.multiArrangments = [];
      this.minWidthRequest = 0;
      this.minHeightRequest = 0;
      this.minAreaRequest = 0;
    }

    MaxRects.prototype.calc = function(rects, callback) {
      var err, i, paddingBothSide, rect, rectIds, uniqueRectIds, _i, _len;
      assert(_.isFunction(callback), "invalid callback");
      if (!(Array.isArray(rects) && rects.length > 0 && _.isFunction(callback))) {
        err = "bad argument, rects:" + rects + ", callback:" + callback;
        callback(err);
        return;
      }
      paddingBothSide = this.padding * 2;
      this.heuristicRing = HEURISTIC_RING_SINGLE_BIN;
      for (i = _i = 0, _len = rects.length; _i < _len; i = ++_i) {
        rect = rects[i];
        rect.width = parseInt(rect.width, 10) || 0;
        rect.height = parseInt(rect.height, 10) || 0;
        rect.id = String(rect.id || i);
        if (!(rect.width > 0 && rect.height > 0 && (rect.id != null))) {
          callback("bad Rectangle data: " + (JSON.stringify(rect)));
          return;
        }
        if (paddingBothSide > 0) {
          rect.width += paddingBothSide;
        }
        if (paddingBothSide > 0) {
          rect.height += paddingBothSide;
        }
        rect.area = rect.width * rect.height;
      }
      rectIds = rects.map(function(el) {
        return el.id;
      });
      uniqueRectIds = _.uniq(rectIds);
      if (rectIds.length !== uniqueRectIds.length) {
        callback("duplicate id found in given rects: " + (_.difference(rectIds, uniqueRectIds)));
        return;
      }
      this._sourceList = rects;
      this.callback = callback;
      this.heuristic = null;
      this.startAt = Date.now();
      this.heuristic = HEURISTIC_BEST_SHORT_SIDE_FIT;
      this.startCalculationFromMiniBinSize();
    };

    MaxRects.prototype.startCalculationFromMiniBinSize = function() {
      var minSize;
      debuglog("[startCalculationFromMiniBinSize] @heuristic:" + this.heuristic);
      this.surfaceArea = calcSurfaceArea(this._sourceList);
      minSize = 2;
      while (minSize <= 512 && (minSize * minSize < this.surfaceArea)) {
        minSize = minSize << 1;
      }
      debuglog("[calc] @surfaceArea:" + this.surfaceArea + "(" + (Math.ceil(Math.sqrt(this.surfaceArea))) + "), minSize:" + minSize);
      this.binWidth = minSize;
      this.binHeight = minSize;
      this.startCalculation();
    };

    MaxRects.prototype.expendBinSize = function() {
      var h, w;
      w = this.binWidth + 128;
      h = this.binHeight + 128;
      debuglog("[expendBinSize] from " + this.binWidth + "x" + this.binHeight + " to " + w + "x" + h);
      if (w <= MAX_BIN_WIDTH && h <= MAX_BIN_HEIGHT) {
        this.binWidth = w;
        this.binHeight = h;
        this.startCalculation();
      } else {
        this.currentArrangementByHeuristicKV[this.heuristic] = CALCULATION_FAILED;
        this.useNextHeuristic();
      }
    };

    MaxRects.prototype.pickArrangement = function() {
      var arrangment, bestArrangement, heuristic;
      bestArrangement = null;
      for (heuristic in this.heuristicRing) {
        arrangment = this.currentArrangementByHeuristicKV[heuristic];
        if (arrangment == null) {
          continue;
        }
        debuglog("[pickArrangement] heuristic:" + arrangment.heuristic + ", occupiedArea:" + arrangment.occupiedArea);
        if (!bestArrangement) {
          bestArrangement = arrangment;
          continue;
        } else {
          if (arrangment.occupiedArea < bestArrangement.occupiedArea) {
            bestArrangement = arrangment;
          }
        }
      }
      debuglog("[pickArrangement] BEST: heuristic:" + bestArrangement.heuristic + ", occupiedArea:" + bestArrangement.occupiedArea);
      return bestArrangement;
    };

    MaxRects.prototype.takeSnapshopt = function() {
      var occupiedArea, result, surfaceArea;
      surfaceArea = calcSurfaceArea(this.usedRectangles);
      occupiedArea = calcOcupiedArea(this.usedRectangles, this.binWidth, this.binHeight);
      result = {
        surfaceArea: surfaceArea,
        occupiedArea: occupiedArea,
        binWidth: this.binWidth,
        binHeight: this.binHeight,
        arrangment: this.usedRectangles,
        heuristic: this.heuristic,
        freeRects: this.freeRectangles,
        plotRatio: surfaceArea / (this.binWidth * this.binHeight),
        timeSpent: Date.now() - this.startAt
      };
      this.startAt = Date.now();
      return result;
    };

    MaxRects.prototype.useNextHeuristic = function() {
      var nextHeuristic;
      nextHeuristic = this.heuristicRing[this.heuristic];
      debuglog("[useNextHeuristic] nextHeuristic:" + nextHeuristic);
      if (nextHeuristic == null) {
        this.complete();
        return;
      }
      this.heuristic = nextHeuristic;
      this.startCalculationFromMiniBinSize();
    };

    MaxRects.prototype.startCalculation = function() {
      debuglog("[startCalculation] @heuristic:" + this.heuristic + " binSize:" + this.binWidth + "x" + this.binHeight);
      this.usedRectangles = [];
      this.freeRectangles = [];
      this.freeRectangles.push(new Rectangle(0, 0, this.binWidth, this.binHeight, 'bin'));
      this.sourceList = this._sourceList.concat();
      this.calcEachRect();
    };

    MaxRects.prototype.calcEachRect = function() {
      var bestNode, bestRectIndex, bestScore1, bestScore2, i, newNode, rect, _i, _len, _ref;
      this.verbos && debuglog("[_calc] @heuristic:" + this.heuristic + ", progress: " + this.usedRectangles.length + "/" + this._sourceList.length);
      if (this.sourceList.length <= 0) {
        this.currentArrangementByHeuristicKV[this.heuristic] = this.takeSnapshopt();
        this.useNextHeuristic();
        return;
      }
      bestScore1 = Number.MAX_VALUE;
      bestScore2 = Number.MAX_VALUE;
      bestRectIndex = -1;
      bestNode = null;
      this.minWidthRequest = Number.MAX_VALUE;
      this.minHeightRequest = Number.MAX_VALUE;
      this.minAreaRequest = Number.MAX_VALUE;
      _ref = this.sourceList;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = _i += 1) {
        rect = _ref[i];
        if (rect.width < this.minWidthRequest) {
          this.minWidthRequest = rect.width;
        }
        if (rect.height < this.minHeightRequest) {
          this.minHeightRequest = rect.height;
        }
        if (rect.area < this.minAreaRequest) {
          this.minAreaRequest = rect.area;
        }
        this.score1 = 0;
        this.score2 = 0;
        newNode = this.scoreRect(rect);
        if (newNode == null) {
          this.expendBinSize();
          return;
        } else {
          if (this.score1 < bestScore1 || (this.score1 === bestScore1 && this.score2 < bestScore2)) {
            bestScore1 = this.score1;
            bestScore2 = this.score2;
            bestNode = newNode;
            bestRectIndex = i;
          }
        }
      }
      this.placeRect(bestNode);
      this.sourceList.splice(bestRectIndex, 1);
      this.pruneFreeList();
      setImmediate((function(_this) {
        return function() {
          return _this.calcEachRect();
        };
      })(this));
    };

    MaxRects.prototype.complete = function() {
      var bestArrangement, err;
      bestArrangement = this.pickArrangement();
      debuglog("[complete] bestArrangement:" + bestArrangement + ", @enableMultiArrangment:" + this.enableMultiArrangment);
      if ((bestArrangement == null) || (bestArrangement === CALCULATION_FAILED)) {
        err = "ERROR [maxrects::complete] overall size of request texture is too large. max texture size allowed is " + MAX_BIN_WIDTH + "x" + MAX_BIN_HEIGHT;
        debuglog("[complete] " + err);
        this.callback(err);
        return;
      }
      if (this.padding > 0) {
        bestArrangement.forEach((function(_this) {
          return function(rect) {
            return rect.shrink(_this.padding);
          };
        })(this));
      }
      if (this.enableMultiArrangment) {
        this.callback(null, [bestArrangement]);
      } else {
        this.callback(null, bestArrangement);
      }
    };

    MaxRects.prototype.placeRect = function(node) {
      var count, i, numRectanglesToProcess;
      this.verbos && debuglog("[maxrects::placeRect] node:" + node);
      count = this.freeRectangles.length;
      this.verbos && debuglog("[maxrects::placeRect] before split, free num:" + this.freeRectangles.length + " #############");
      i = 0;
      numRectanglesToProcess = this.freeRectangles.length;
      while (i < numRectanglesToProcess) {
        if (this.splitFreeNode(this.freeRectangles[i], node)) {
          this.freeRectangles.splice(i, 1);
          --numRectanglesToProcess;
          --i;
        }
        ++i;
      }
      this.verbos && debuglog("[maxrects::placeRect] after split, free num:" + this.freeRectangles.length + "; i:" + i + ", increase:" + (this.freeRectangles.length - count));
      this.usedRectangles.push(node);
    };

    MaxRects.prototype.splitFreeNode = function(freeNode, usedNode) {
      var change, debug_countBefore;
      debug_countBefore = this.freeRectangles.length;
      if (usedNode.left >= freeNode.right || usedNode.right <= freeNode.left || usedNode.top >= freeNode.bottom || usedNode.bottom <= freeNode.top) {
        return false;
      }
      if (usedNode.left < freeNode.right && usedNode.right > freeNode.left) {
        if (usedNode.top > freeNode.top && usedNode.top < freeNode.bottom) {
          change = usedNode.top - freeNode.top - this.margin;
          if (change >= this.minHeightRequest && freeNode.width * change > this.minAreaRequest) {
            this.freeRectangles.push(new Rectangle(freeNode.left, freeNode.top, freeNode.width, change, 'f'));
          }
        }
        if (usedNode.bottom < freeNode.bottom) {
          change = freeNode.bottom - usedNode.bottom - this.margin;
          if (change >= this.minHeightRequest && freeNode.width * change > this.minAreaRequest) {
            this.freeRectangles.push(new Rectangle(freeNode.left, usedNode.bottom + this.margin, freeNode.width, change, 'f'));
          }
        }
      }
      if (usedNode.top < freeNode.bottom && usedNode.bottom > freeNode.top) {
        if (usedNode.left > freeNode.left && usedNode.left < freeNode.right) {
          change = usedNode.left - freeNode.left - this.margin;
          if (change >= this.minWidthRequest && change * freeNode.height > this.minAreaRequest) {
            this.freeRectangles.push(new Rectangle(freeNode.left, freeNode.top, change, freeNode.height, 'f'));
          }
        }
        if (usedNode.right < freeNode.right) {
          change = freeNode.right - usedNode.right - this.margin;
          if (change >= this.minWidthRequest && change * freeNode.height > this.minAreaRequest) {
            this.freeRectangles.push(new Rectangle(usedNode.right + this.margin, freeNode.top, change, freeNode.height, 'f'));
          }
        }
      }
      return true;
    };

    MaxRects.prototype.scoreRect = function(rect) {
      var height, id, newNode, width;
      id = rect.id;
      width = rect.width;
      height = rect.height;
      this.score1 = Number.MAX_VALUE;
      this.score2 = Number.MAX_VALUE;
      newNode = null;
      switch (this.heuristic) {
        case HEURISTIC_BEST_SHORT_SIDE_FIT:
          newNode = this.findPositionForBSSF(id, width, height);
          break;
        case HEURISTIC_BEST_LONG_SIDE_FIT:
          newNode = this.findPositionForBLSF(id, width, height);
          break;
        case HEURISTIC_BEST_AREA_FIT:
          newNode = this.findPositionForBAF(id, width, height);
          break;
        case HEURISTIC_BOTTOM_LEFT_RULE:
          newNode = this.findPositionForBL(id, width, height);
          break;
        case HEURISTIC_CONTACT_POINT_RULE:
          newNode = this.findPositionForCP(id, width, height);
          this.score1 = -this.score1;
      }
      if ((newNode == null) || newNode.height === 0) {
        this.verbos && debuglog("[maxrects::scoreRect] fail to score node");
        this.score1 = Number.MAX_VALUE;
        this.score2 = Number.MAX_VALUE;
      }
      return newNode;
    };

    MaxRects.prototype.findPositionForBSSF = function(id, width, height) {
      var bestNode, foundFitNode, leftoverHoriz, leftoverVert, longSideFit, rect, shortSideFit, _i, _len, _ref;
      this.score1 = Number.MAX_VALUE;
      bestNode = new Rectangle(0, 0, 0, 0, id);
      foundFitNode = false;
      _ref = this.freeRectangles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rect = _ref[_i];
        leftoverHoriz = rect.width - width;
        leftoverVert = rect.height - height;
        if (leftoverHoriz < 0 || leftoverVert < 0) {
          continue;
        }
        shortSideFit = Math.min(leftoverHoriz, leftoverVert);
        longSideFit = Math.max(leftoverHoriz, leftoverVert);
        if (shortSideFit < this.score1 || (shortSideFit === this.score1 && longSideFit < this.score2)) {
          foundFitNode = true;
          bestNode.reset(rect.left, rect.top, width, height);
          this.score1 = shortSideFit;
          this.score2 = longSideFit;
        }
      }
      if (foundFitNode) {
        return bestNode;
      } else {
        return null;
      }
    };

    MaxRects.prototype.findPositionForBLSF = function(id, width, height) {
      var bestNode, foundFitNode, leftoverHoriz, leftoverVert, longSideFit, rect, shortSideFit, _i, _len, _ref;
      this.verbos && debuglog("[maxrects::findPositionForBLSF] id:" + id + ", width:" + width + ", height:" + height);
      this.score2 = Number.MAX_VALUE;
      bestNode = new Rectangle(0, 0, 0, 0, id);
      foundFitNode = false;
      _ref = this.freeRectangles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rect = _ref[_i];
        leftoverHoriz = rect.width - width;
        leftoverVert = rect.height - height;
        if (leftoverHoriz < 0 || leftoverVert < 0) {
          continue;
        }
        shortSideFit = Math.min(leftoverHoriz, leftoverVert);
        longSideFit = Math.max(leftoverHoriz, leftoverVert);
        if (longSideFit < this.score2 || (longSideFit === this.score2 && shortSideFit < this.score1)) {
          foundFitNode = true;
          this.verbos && debuglog("[maxrects::findPositionForBLSF] bestNode.reset(" + rect.left + ", " + rect.top + ", " + width + ", " + height + ")");
          bestNode.reset(rect.left, rect.top, width, height);
          this.score1 = shortSideFit;
          this.score2 = longSideFit;
        }
      }
      if (foundFitNode) {
        return bestNode;
      } else {
        return null;
      }
    };

    MaxRects.prototype.findPositionForBAF = function(id, width, height) {
      var areaFit, bestNode, foundFitNode, leftoverHoriz, leftoverVert, rect, requestArea, shortSideFit, _i, _len, _ref;
      this.score1 = Number.MAX_VALUE;
      bestNode = new Rectangle(0, 0, 0, 0, id);
      foundFitNode = false;
      requestArea = width * height;
      _ref = this.freeRectangles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rect = _ref[_i];
        leftoverHoriz = rect.width - width;
        leftoverVert = rect.height - height;
        if (leftoverHoriz < 0 || leftoverVert < 0) {
          continue;
        }
        areaFit = rect.area - requestArea;
        shortSideFit = Math.min(leftoverHoriz, leftoverVert);
        if (areaFit < this.score1 || (areaFit === this.score1 && shortSideFit < this.score2)) {
          foundFitNode = true;
          this.verbos && debuglog("[maxrects::findPositionForBAF] bestNode.reset(" + rect.left + ", " + rect.top + ", " + width + ", " + height + ")");
          bestNode.reset(rect.left, rect.top, width, height);
          this.score1 = areaFit;
          this.score2 = shortSideFit;
        }
      }
      if (foundFitNode) {
        return bestNode;
      } else {
        return null;
      }
    };

    MaxRects.prototype.findPositionForBL = function(id, width, height) {
      var bestNode, foundFitNode, rect, topSideY, _i, _len, _ref;
      this.score1 = Number.MAX_VALUE;
      bestNode = new Rectangle(0, 0, 0, 0, id);
      foundFitNode = false;
      _ref = this.freeRectangles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rect = _ref[_i];
        if (rect.width < width || rect.height < height) {
          continue;
        }
        topSideY = rect.top + height;
        if (topSideY < this.score1 || (topSideY === this.score1 && rect.left < this.score2)) {
          foundFitNode = true;
          this.verbos && debuglog("[maxrects::findPositionForBL] bestNode.reset(" + rect.left + ", " + rect.top + ", " + width + ", " + height + ")");
          bestNode.reset(rect.left, rect.top, width, height);
          this.score1 = topSideY;
          this.score2 = rect.left;
        }
      }
      if (foundFitNode) {
        return bestNode;
      } else {
        return null;
      }
    };

    MaxRects.prototype.findPositionForCP = function(id, width, height) {
      var bestNode, foundFitNode, rect, score, _i, _len, _ref;
      this.score1 = -1;
      bestNode = new Rectangle(0, 0, 0, 0, id);
      foundFitNode = false;
      _ref = this.freeRectangles;
      for (_i = 0, _len = _ref.length; _i < _len; _i += 1) {
        rect = _ref[_i];
        if (rect.width < width || rect.height < height) {
          continue;
        }
        score = this.contactPointScoreNode(rect.left, rect.top, width, height);
        if (score > this.score1) {
          foundFitNode = true;
          this.verbos && debuglog("[maxrects::findPositionForCP] bestNode.reset(" + rect.left + ", " + rect.top + ", " + width + ", " + height + ")");
          bestNode.reset(rect.left, rect.top, width, height);
          this.score1 = score;
        }
      }
      if (foundFitNode) {
        return bestNode;
      } else {
        return null;
      }
    };

    MaxRects.prototype.contactPointScoreNode = function(left, top, width, height) {
      var bottom, rect, right, score, _i, _len, _ref;
      score = 0;
      right = left + width;
      bottom = top + height;
      if (left === 0 || right === this.binWidth) {
        score += height;
      }
      if (top === 0 || bottom === this.binHeight) {
        score += width;
      }
      _ref = this.usedRectangles;
      for (_i = 0, _len = _ref.length; _i < _len; _i += 1) {
        rect = _ref[_i];
        if (rect.left === right || rect.right === left) {
          score += commonIntervalLength(rect.top, rect.bottom, top, bottom);
        }
        if (rect.top === bottom || rect.bottom === top) {
          score += commonIntervalLength(rect.left, rect.right, left, right);
        }
      }
      return score;
    };

    MaxRects.prototype.pruneFreeList = function() {
      var i, j, rect;
      this.verbos && debuglog("[maxrects::pruneFreeList] count before:" + this.freeRectangles.length + ", @minWidthRequest:" + this.minWidthRequest + ", @minHeightRequest:" + this.minHeightRequest + ", @minAreaRequest:" + this.minAreaRequest);
      this.verbos && debuglog("[maxrects::pruneFreeList] @surfaceArea:" + this.surfaceArea + "(" + (Math.ceil(Math.sqrt(this.surfaceArea))) + "), @binWidth:" + this.binWidth + ", @binHeight:" + this.binHeight);
      i = 0;
      mainloop: //;
      while (i < this.freeRectangles.length) {
        rect = this.freeRectangles[i];
        if (rect.width < this.minWidthRequest || rect.height < this.minHeightRequest || rect.area < this.minAreaRequest) {
          this.verbos && debuglog("[maxrects::pruneFreeList] 剔除超小区域$$$$$$$$$$$$$$");
          this.freeRectangles.splice(i, 1);
          continue mainloop;
        }
        j = i + 1;
        subloop: //;
        while (j < this.freeRectangles.length) {
          if (this.freeRectangles[j].contains(this.freeRectangles[i])) {
            this.freeRectangles.splice(i, 1);
            continue mainloop;
          } else if (this.freeRectangles[i].contains(this.freeRectangles[j])) {
            this.freeRectangles.splice(j, 1);
            continue subloop;
          } else {
            ++j;
          }
        }
        ++i;
      }
      this.verbos && debuglog("[maxrects::pruneFreeList] count after:" + this.freeRectangles.length);
    };

    return MaxRects;

  })();

  exports = module.exports;

  exports.MaxRects = MaxRects;

}).call(this);
